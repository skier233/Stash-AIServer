name: Release (wheels -> PyPI -> GHCR image)

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

jobs:
  determine:
    name: Determine tag + version
    runs-on: ubuntu-latest
    outputs:
      is_release: ${{ steps.set.outputs.is_release }}
      tag: ${{ steps.set.outputs.tag }}
      version: ${{ steps.set.outputs.version }}
      is_final: ${{ steps.set.outputs.is_final }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - id: set
        run: |
          REF="${GITHUB_REF}"
          if [[ "$REF" == refs/tags/v* ]]; then
            TAG="${REF#refs/tags/}"
            VERSION=${TAG#v}
            git fetch origin main --depth=1 || true
            COMMIT=$(git rev-parse "$REF")
            if git merge-base --is-ancestor "$COMMIT" origin/main; then
              echo "is_release=true" >> $GITHUB_OUTPUT
            else
              echo "is_release=false" >> $GITHUB_OUTPUT
            fi
            echo "tag=${TAG}" >> $GITHUB_OUTPUT
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "is_final=true" >> $GITHUB_OUTPUT
            else
              echo "is_final=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            SHORT_SHA=$(git rev-parse --short HEAD)
            echo "tag=dev-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "version=0.0.0" >> $GITHUB_OUTPUT
            echo "is_final=false" >> $GITHUB_OUTPUT
          fi

  build-wheel:
    name: Build wheel (universal)
    runs-on: ubuntu-latest
    needs: determine
    if: needs.determine.outputs.is_release == 'true'
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Sync version from tag
        env:
          VERSION: ${{ needs.determine.outputs.version }}
        run: |
          echo "Setting backend/pyproject.toml version to $VERSION"
          python - <<'PY'
          import pathlib, os, re
          p=pathlib.Path('backend/pyproject.toml')
          s=p.read_text(encoding='utf8')
          v=os.environ['VERSION']
          # Try to replace an existing version line first
          new, n = re.subn(r'(?m)^version\s*=\s*"[^"]+"', f'version = "{v}"', s)
          if n == 0:
              # Insert the version under the [project] table if missing
              parts = s.split('\n')
              out = []
              inserted = False
              i = 0
              while i < len(parts):
                  out.append(parts[i])
                  if parts[i].strip() == '[project]' and not inserted:
                      # insert on next line
                      i += 1
                      out.append(f'version = "{v}"')
                      inserted = True
                      continue
                  i += 1
              new = '\n'.join(out)
          p.write_text(new, encoding='utf8')
          print('Updated version ->', v)
          PY
      - name: Install build tooling
        run: python -m pip install --upgrade pip setuptools wheel build
      - name: Build wheel
        working-directory: backend
        run: python -m build --wheel
      - name: Show dist contents
        run: ls -l backend/dist
      - name: Upload wheel artifact
        uses: actions/upload-artifact@v5
        with:
          name: wheel
          path: backend/dist/*.whl

  publish:
    name: Publish wheel to PyPI
    runs-on: ubuntu-latest
    needs: [determine, build-wheel]
    if: needs.determine.outputs.is_release == 'true'
    steps:
      - name: Download wheel artifact
        uses: actions/download-artifact@v6
        with:
          name: wheel
          path: dist_dl
      - name: List wheel
        run: ls -l dist_dl
      - name: Validate wheel version
        env:
          VERSION: ${{ needs.determine.outputs.version }}
        run: |
          python - <<'PY'
          import os, zipfile, sys, glob
          v=os.environ['VERSION']
          bad=0
          for w in glob.glob('dist_dl/*.whl'):
            with zipfile.ZipFile(w) as z:
              meta=[n for n in z.namelist() if n.endswith('METADATA')]
              if not meta: print('No METADATA in', w); bad+=1; continue
              text=z.read(meta[0]).decode()
              for line in text.splitlines():
                if line.startswith('Version:'):
                  got=line.split(':',1)[1].strip()
                  if got!=v:
                    print('Mismatch', w, got, '!=', v); bad+=1
                  else:
                    print('OK', w, got)
                  break
          sys.exit(bad)
          PY
      - name: Install twine
        run: python -m pip install --upgrade twine
      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: python -m twine upload dist_dl/*.whl

  package-assets:
    name: Prepare release bundles
    runs-on: ubuntu-latest
    needs: determine
    if: needs.determine.outputs.is_release == 'true'
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Build backend and docker bundles
        env:
          VERSION: ${{ needs.determine.outputs.version }}
          IS_FINAL: ${{ needs.determine.outputs.is_final }}
        run: |
          set -euo pipefail
          ROOT="$PWD"
          mkdir -p release

          # Backend bundle
          BACK_STAGE="$ROOT/release/backend-stage"
          rm -rf "$BACK_STAGE"
          mkdir -p "$BACK_STAGE"
          cp backend/environment.yml "$BACK_STAGE/"
          cp backend/requirements.txt "$BACK_STAGE/"
          if [ "$IS_FINAL" != 'true' ]; then
            echo "pinning backend requirements stash-ai-server dependency to $VERSION"
            BACK_STAGE_PATH="$BACK_STAGE" python - <<'PY'
          import pathlib, os, re

          release = os.environ['VERSION']
          path = pathlib.Path(os.environ['BACK_STAGE_PATH']) / 'requirements.txt'
          if not path.exists():
              raise SystemExit(f'requirements.txt missing at {path}')
          text = path.read_text()
          pattern = re.compile(r'^(stash-ai-server)(?:\s*==\s*[^\s]+)?\s*$', re.MULTILINE)
          if pattern.search(text):
              text = pattern.sub(f'stash-ai-server=={release}', text, 1)
          else:
              if text and not text.endswith('\n'):
                  text += '\n'
              text += f'stash-ai-server=={release}\n'
          path.write_text(text)
          print('replaced stash-ai-server line with version', release)
          PY
          fi
          cp backend/config.sample.env "$BACK_STAGE/config.env"
          mkdir -p "$BACK_STAGE/data" "$BACK_STAGE/plugins"
          (cd "$BACK_STAGE" && zip -r "$ROOT/release/stash-ai-server-backend-${VERSION}.zip" .)
          rm -rf "$BACK_STAGE"

          # Docker bundle
          DOCKER_STAGE="$ROOT/release/docker-stage"
          rm -rf "$DOCKER_STAGE"
          mkdir -p "$DOCKER_STAGE"
          cp docker-compose.yml "$DOCKER_STAGE/"
          if [ "$IS_FINAL" != 'true' ]; then
            echo "non-final release detected; pinning backend_prod image to version $VERSION"
            (cd "$DOCKER_STAGE" && sed -i "s|ghcr.io/${{ github.repository_owner }}/stash-ai-server:latest|ghcr.io/${{ github.repository_owner }}/stash-ai-server:${VERSION}|g" docker-compose.yml)
          fi
          cp backend/config.docker.sample.env "$DOCKER_STAGE/config.env"
          mkdir -p "$DOCKER_STAGE/data" "$DOCKER_STAGE/plugins"
          (cd "$DOCKER_STAGE" && zip -r "$ROOT/release/stash-ai-server-docker-${VERSION}.zip" .)
          rm -rf "$DOCKER_STAGE"

          ls -l release
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install frontend dependencies
        working-directory: frontend
        run: npm install
      - name: Build frontend
        working-directory: frontend
        run: npm run build
      - name: Stamp AIOverhaul version
        env:
          RELEASE_VERSION: ${{ needs.determine.outputs.version }}
        run: |
          python - <<'PY'
          import os
          from pathlib import Path
          import re

          release = os.environ['RELEASE_VERSION']
          path = Path('frontend/dist/AIOverhaul.yml')
          if not path.exists():
              raise SystemExit(f'AIOverhaul.yml not found at {path}')
          text = path.read_text()
          pattern = re.compile(r'^version\s*:\s*.*$', re.MULTILINE)
          if not pattern.search(text):
              raise SystemExit('version field missing in AIOverhaul.yml')
          new_text = pattern.sub(f'version: {release}', text, 1)
          path.write_text(new_text)
          print('Stamped AIOverhaul.yml to version', release)
          PY
      - name: Package frontend bundle
        env:
          VERSION: ${{ needs.determine.outputs.version }}
        run: |
          set -euo pipefail
          ROOT="$PWD"
          mkdir -p release
          if [ ! -d frontend/dist ]; then
            echo "dist folder missing after build" >&2
            exit 1
          fi
          (cd frontend/dist && zip -r "$ROOT/release/stash-ai-server-frontend-${VERSION}.zip" .)
          ls -l release
      - name: Upload frontend dist artifact
        uses: actions/upload-artifact@v5
        with:
          name: frontend-dist
          path: frontend/dist
      - name: Upload release bundles
        uses: actions/upload-artifact@v5
        with:
          name: release-bundles
          path: |
            release/stash-ai-server-backend-${{ needs.determine.outputs.version }}.zip
            release/stash-ai-server-docker-${{ needs.determine.outputs.version }}.zip
            release/stash-ai-server-frontend-${{ needs.determine.outputs.version }}.zip

  community-plugin:
    name: Publish AI Overhaul plugin to CommunityScripts
    runs-on: ubuntu-latest
    needs: [determine, package-assets]
    if: needs.determine.outputs.is_final == 'true'
    env:
      RELEASE_VERSION: ${{ needs.determine.outputs.version }}
      COMMUNITY_BRANCH: release/ai-overhaul-${{ needs.determine.outputs.version }}
      COMMUNITY_FORK_REPO: ${{ secrets.COMMUNITY_SCRIPTS_FORK != '' && secrets.COMMUNITY_SCRIPTS_FORK || 'skier233/CommunityScripts' }}
      COMMUNITY_UPSTREAM_REPO: ${{ secrets.COMMUNITY_SCRIPTS_UPSTREAM != '' && secrets.COMMUNITY_SCRIPTS_UPSTREAM || 'stashapp/CommunityScripts' }}
      COMMUNITY_BASE: ${{ secrets.COMMUNITY_SCRIPTS_BASE != '' && secrets.COMMUNITY_SCRIPTS_BASE || 'main' }}
    steps:
      - name: Check CommunityScripts PAT
        id: guard_pat
        run: |
          if [ -z "${{ secrets.COMMUNITY_SCRIPTS_PAT }}" ]; then
            echo "COMMUNITY_SCRIPTS_PAT is not set; skipping CommunityScripts publishing."
            echo "has_pat=false" >> $GITHUB_OUTPUT
          else
            echo "has_pat=true" >> $GITHUB_OUTPUT
          fi
      - name: Checkout Stash AI Server
        if: steps.guard_pat.outputs.has_pat == 'true'
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Download frontend dist artifact
        if: steps.guard_pat.outputs.has_pat == 'true'
        uses: actions/download-artifact@v6
        with:
          name: frontend-dist
          path: frontend/dist
      - name: Checkout CommunityScripts repo
        if: steps.guard_pat.outputs.has_pat == 'true'
        uses: actions/checkout@v5
        with:
          repository: ${{ env.COMMUNITY_FORK_REPO }}
          token: ${{ secrets.COMMUNITY_SCRIPTS_PAT }}
          path: community-scripts
          fetch-depth: 0
      - name: Sync fork base branch with upstream
        if: steps.guard_pat.outputs.has_pat == 'true'
        run: |
          set -euo pipefail
          cd community-scripts
          git remote remove upstream >/dev/null 2>&1 || true
          git remote add upstream "https://github.com/${COMMUNITY_UPSTREAM_REPO}.git"
          git fetch upstream "$COMMUNITY_BASE"
          git checkout "$COMMUNITY_BASE"
          git reset --hard "upstream/${COMMUNITY_BASE}"
          git push origin "$COMMUNITY_BASE" --force-with-lease
      - name: Sync AI Overhaul bundle
        if: steps.guard_pat.outputs.has_pat == 'true'
        run: |
          set -euo pipefail
          mkdir -p community-scripts/plugins/AIOverhaul
          rsync -a --delete --exclude '__pycache__' frontend/dist/ community-scripts/plugins/AIOverhaul/
      - name: Detect changes
        if: steps.guard_pat.outputs.has_pat == 'true'
        id: community_changes
        run: |
          cd community-scripts
          if git status --short plugins/AIOverhaul | grep .; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      - name: Commit changes
        if: steps.guard_pat.outputs.has_pat == 'true' && steps.community_changes.outputs.changed == 'true'
        run: |
          cd community-scripts
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -B "$COMMUNITY_BRANCH" "$COMMUNITY_BASE"
          git add plugins/AIOverhaul
          git commit -m "Update AI Overhaul plugin for $RELEASE_VERSION"
      - name: Push branch
        if: steps.guard_pat.outputs.has_pat == 'true' && steps.community_changes.outputs.changed == 'true'
        env:
          GIT_TOKEN: ${{ secrets.COMMUNITY_SCRIPTS_PAT }}
        run: |
          cd community-scripts
          git push origin "$COMMUNITY_BRANCH" --force-with-lease
      - name: Create pull request
        if: steps.guard_pat.outputs.has_pat == 'true' && steps.community_changes.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.COMMUNITY_SCRIPTS_PAT }}
        run: |
          cd community-scripts
          FORK_OWNER="${COMMUNITY_FORK_REPO%%/*}"
          gh pr create \
            --repo "$COMMUNITY_UPSTREAM_REPO" \
            --title "Update AI Overhaul plugin for $RELEASE_VERSION" \
            --body "Automated update from stash-ai-server $RELEASE_VERSION" \
            --base "$COMMUNITY_BASE" \
            --head "${FORK_OWNER}:$COMMUNITY_BRANCH" || echo "PR creation skipped (possibly already exists)"
      - name: No changes detected
        if: steps.guard_pat.outputs.has_pat == 'true' && steps.community_changes.outputs.changed != 'true'
        run: echo "CommunityScripts plugin already up to date; skipping PR"

  image:
    name: Build & push GHCR image
    runs-on: ubuntu-latest
    needs: [determine, publish]
    if: needs.determine.outputs.is_release == 'true'
    steps:
      - uses: actions/checkout@v5
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Wait for PyPI to index published wheel
        env:
          VERSION: ${{ needs.determine.outputs.version }}
        run: |
          python - <<'PY'
          import os, time, sys, urllib.request, json
          v=os.environ['VERSION']
          url='https://pypi.org/pypi/stash-ai-server/json'
          attempts=0
          found=False
          max_attempts=5
          while attempts < max_attempts:
              try:
                  with urllib.request.urlopen(url, timeout=15) as r:
                      data=json.load(r)
                      if v in data.get('releases', {}):
                          print('PyPI has version', v)
                          found=True
                          break
              except Exception as e:
                  print('check failed', e)
              attempts += 1
              print(f'retry {attempts}/{max_attempts} sleeping 20s')
              time.sleep(20)
          if not found:
              print('Version not found on PyPI after retries; aborting')
              sys.exit(1)
          PY
      - name: Build & push
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: runtime
          build-args: |
            VERSION=${{ needs.determine.outputs.version }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ github.repository_owner }}/stash-ai-server:${{ needs.determine.outputs.version }}
            ${{ needs.determine.outputs.is_final == 'true' && format('ghcr.io/{0}/stash-ai-server:latest', github.repository_owner) || '' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  github-release:
    name: Publish GitHub release
    runs-on: ubuntu-latest
    needs: [determine, publish, image, package-assets]
    if: needs.determine.outputs.is_release == 'true'
    steps:
      - uses: actions/download-artifact@v6
        with:
          name: release-bundles
          path: release_assets
      - id: find_release
        name: Check for existing GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.determine.outputs.tag }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$API") || true
          if echo "$resp" | grep -q '"message": "Not Found"'; then
            echo "exists=false" >> $GITHUB_OUTPUT
          else
            echo "exists=true" >> $GITHUB_OUTPUT
            upload_url=$(printf '%s\n' "$resp" | jq -r '.upload_url // ""')
            echo "upload_url=${upload_url}" >> $GITHUB_OUTPUT
          fi

      - name: Upload bundles to existing release
        if: steps.find_release.outputs.exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          upload_url="${{ steps.find_release.outputs.upload_url }}"
          upload_url="${upload_url%%\{*}"
          for file in release_assets/*.zip; do
            name=$(basename "$file")
            echo "Uploading $name to $upload_url"
            curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/zip" --data-binary @"$file" "${upload_url}?name=${name}"
          done

      - name: Publish GitHub release
        if: steps.find_release.outputs.exists != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.determine.outputs.tag }}
          name: Stash AI Server ${{ needs.determine.outputs.version }}
          draft: false
          prerelease: ${{ needs.determine.outputs.is_final != 'true' }}
          make_latest: ${{ needs.determine.outputs.is_final == 'true' && 'true' || 'false' }}
          generate_release_notes: true
          files: |
            release_assets/stash-ai-server-backend-${{ needs.determine.outputs.version }}.zip
            release_assets/stash-ai-server-docker-${{ needs.determine.outputs.version }}.zip
            release_assets/stash-ai-server-frontend-${{ needs.determine.outputs.version }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 